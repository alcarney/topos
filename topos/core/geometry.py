from abc import ABC, abstractmethod

from .errors import ToposError
from .faces import FaceArray
from .vertices import VertexArray
from .generators import cylindrical_faces


class GeometryNameError(ToposError):
    """A geometry name error."""


class Geometry(ABC):
    """An abstract class which models the notion of "geometry".

    By pulling out what makes "geometry" into its own abstract
    class anything that manipulates geometry can operate on
    a clearly defined interface regardless of what that object
    actually is.

    For example, the file format writers can define their methods
    once and work for any object whether it be a mesh, a world view
    etc.

    Currently there are only two properties that need to be overriden
    in order to define a new geometry representing format:

    - :code:`vertices`: This should return a :code:`VertexArray`
                        representing the object's vertices
    - :code:`faces`: This should return a :code:`FaceArray` representing
                     the object's faces.
    """

    @property
    def name(self):
        """The name of the geometry object."""

        if self._name is None:
            return "Geometry"

        return self._name

    @name.setter
    @GeometryNameError
    def name(self, value):

        if isinstance(value, (str,)):
            self._name = value
            return

        raise TypeError('Name must be represented by a string.')

    def _repr_hook(self):
        """This method will be called whenever the object's __repr__ string
        is asked for.

        Implementing classes should override this method to add any extra
        information to their instances' __repr__ strings."""
        return ""

    def __repr__(self):
        string = "{}\n".format(self.name)

        string += self._repr_hook()

        if self.vertices is not None:
            string += "Vertices: {}\n".format(self.vertices.length)

        if self.faces is not None:
            string += "Faces: {}\n".format(self.faces.length)

        return string

    @property
    @abstractmethod
    def vertices(self):
        """Return the VertexArray which defines the vertices in the object."""
        pass

    @property
    @abstractmethod
    def faces(self):
        """Return the FaceArray which defines the faces in the object."""
        pass

    def save(self, filename):
        """Save the geometry to file in OBJ format.

        :param filename: The path to the file to write the data to
        :type filename: str
        """

        with open(filename, 'w') as f:

            f.write("o {}\n".format(self.name))

            if self.vertices is not None:
                f.write(self.vertices.fmt("v {} {} {}", suffix="\n"))

            if self.faces is not None:
                face_str = " ".join("{}" for _ in range(self.faces.num_sides))
                f.write(self.faces.fmt("f " + face_str))


class MeshDataError(ToposError):
    """A mesh data error."""


class Mesh(Geometry):
    """A simple container for geometry data.

    This is the simplest implementation of the :code:`Geometry` interface
    it is purely a dumb container for geometry data.
    """

    @MeshDataError
    def __init__(self, verts=None, faces=None, name=None):

        if verts is not None and not isinstance(verts, (VertexArray,)):
            raise TypeError('Vertices must be represented by a VertexArray')

        if faces is not None and not isinstance(faces, (FaceArray,)):
            raise TypeError('Faces must be represented by a FaceArray')


        self._verts = verts
        self._faces = faces
        self._name = name

    @property
    def vertices(self):
        return self._verts

    @property
    def faces(self):
        return self._faces


class PathExtruder(Geometry):
    """Given a cross section and path functions this contructs
    the object generated by extruding that cross section along
    the given path.

    The path is given by a function
    :math:`\\gamma: [0, 1] \\rightarrow \\mathbb{R}^3` which gives
    the position of the centre of each cross section at each step.

    The cross section is given by a function
    :math:`r: [0, 2\\pi] \\times \mathbb{R} \\rightarrow [0, \\infty)`
    and will be called for each point around cross section and should
    return the radius from the centre of that point.
    """

    def __init__(self, x_section=None, path=None, N_steps=4):

        self.x_section = x_section
        self.path = path
        self.N_steps = N_steps

    @property
    def vertices(self):
        pass


    @property
    def faces(self):
        pass
